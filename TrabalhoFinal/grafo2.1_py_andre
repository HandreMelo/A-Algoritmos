def menor_caminho(caminhos):
   if caminhos:  # Se a lista não estiver vazia
      print('Todos os possíveos caminhos: ', caminhos)
      print('teste : ')
      peso_vvk=0
      peso_antes=999999
      for i in range(len(caminhos)):
         #print(len(caminhos))
         print('Caminho no : ' + str(i))
         for j in range(len(caminhos[i])-1):
            vertice_key = caminhos[i][j] #um vertice 'A':
            adjacente_vk = caminhos[i][j+1]
            valores_vk = grafo[vertice_key] #valores desse vertice 'A': -> [['B','C']['1','2']]
            indice_adj = valores_vk[0].index(adjacente_vk)
            print('>'+valores_vk[1][indice_adj])
            peso_vvk += int(valores_vk[1][indice_adj])
         if peso_vvk<peso_antes:
            #print(peso_vvk)
            peso_antes=peso_vvk
            peso_vvk=0
      print('Menor peso : ' + str(peso_antes))       
   else:
      print('Este caminho não é possível')

def mostrar_caminho(dicionario):
   for key, value in dicionario.items():
       print(key, value)

#dicionario = grafo
def depth_dirst_search(dicionario, inicio, fim):
    #aqui é o tal TRAVA no primeiro
   print(dicionario[inicio])
   pilha = [(inicio, [inicio])]

   #for key, value in test_dict.items(): 
   #print (key, value) 

   while pilha:
        #o *vertice é um único valor e *caminho uma lista de vertices...
        #...extraídos de *pilha, por isso,while pilha, porque ela tende a ficar vazia
       vertice, caminho = pilha.pop()
    #dicionario[vertice][0] - caminho, segue a lista até não haver Não repetidos
    #o set(dicionario[v][0] - set(caminho) esta testando se esse vertice ja nao existe na lista caminho.
       for proximo in set(dicionario[vertice][0]) - set(caminho):
           if proximo == fim:
               yield caminho + [proximo]
           else:
            #e aqui, enquanto não achar, adiciona na pilha quem vai ser o proximo a ser analisado e..
            #...já colocando como caminho passado
               pilha.append((proximo, caminho + [proximo]))

#A set is an unordered collection with no duplicate elements. 
#Basic uses include membership testing and eliminating duplicate entries.


def sair():
   return ""

grafo = {}
def ler_arquivo():
    vetor_ler = []
    arquivo_destino = open('grafo.txt', 'r')
    for linha in arquivo_destino:
        vetor_ler.append(linha.strip())        

    arquivo_destino.close()

    for i in range(len(vetor_ler)):
        vetor_ler[i] = vetor_ler[i].replace("'", "").replace("‘","").replace("’","")

    pesos = []
    vertices = []

    n = int(vetor_ler[0])
    
    for i in range(2,n+2):
        pesos.append(vetor_ler[i].split(','))

    vertices.append(vetor_ler[1].split(','))
    vertices = vertices[0]

    adjacentes=[]
    pesos_temp=[]
    
    for i in range(n):
        for j in range(n):
            if pesos[i][j] != '0':
               adjacentes.append(vertices[j])
               pesos_temp.append(pesos[i][j])
        grafo[vertices[i]] = [adjacentes,pesos_temp]
        adjacentes=[]
        pesos_temp=[]

lista_vertices = []
ler_arquivo()
while (True):

   print('Digite 1: Mostrar os conjuntos de vértices e arestas')
   print('Digite 2: Responder se um vértice é alcançável diretamente a partir de outro')
   print('Digite 3: Depth Dirst Search:')
   print('Digite 0: Sair')
   argument = input()
    
   if argument == '0':
       print('Programa Finalizado')
       break

   elif argument == '1':
       print(grafo) 

   elif argument == '2':
       mostrar_caminho(grafo)

   elif argument == '3':
       
       inicio_vertice = input('Diga qual o vértice de início: ')
       fim_vertice = input('Diga qual o vértice de saída: ')
       caminhos = list(depth_dirst_search(grafo, inicio_vertice, fim_vertice))
       menor_caminho(caminhos)
   else:
       print('Valor incorreto')

# https://pt.stackoverflow.com/questions/67593/grafo-caminhos-poss%C3%ADveis-python
# algoritmo de dijkstra
